# qx86-rust
Rust implementation of the Qtum-x86 subset of the x86 architecture

## The subset of x86

The Qtum-x86 subset of the x86 architecture is defined as the following:

* The top bit of an address is set if accessing mutable memory (anything >2Gb)
* Segment registers are never used. Segment register override prefixes are ignored (though not invalid) and opcodes which explictly operate on segment registers including far jmps and far calls will throw an invalid opcode exception
* Each opcode can be no larger than 16 bytes (x86 specification limit)
* From the beginning of each opcode's location in memory, at least 16 bytes must be readable afterwards. This means that in a memory the size of 100 bytes, no reachable opcode can be placed after the 84th byte
* All values in EFLAGS are ignored and treated as 0 except for AF, CF, ZF, PHF, and SF
* External interrupt behavior is completely ignored, there is no external interrupt support
* All memory below 0x10000 is inaccessible. This makes 16-bit addressing useless aside from with LEA. Aside from LEA, any other opcode with an address override prefix will be treated as an invalid opcode. 

Instruction Set:

The instruction set supported is a subset of i686. All common opcodes generated by compilers will be supported, with the exception of FPU opcodes. 

* Instructions which require priviledge are disallowed
* Instructions which test if memory using a segment register is readable is invalid
* The BOUND instruction is invalid (never used by compilers due to unpredictable interrupt behavior, and requires a special QWord pipeline path to implement otherwise)


